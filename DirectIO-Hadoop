 .../hadoop/hdfs/server/datanode/BlockSender.java   | 85 +++++++++++++++++++---
 1 file changed, 75 insertions(+), 10 deletions(-)

diff --git a/hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BlockSender.java b/hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BlockSender.java
index 3ff5c75..55cc204 100644
--- a/hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BlockSender.java
+++ b/hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BlockSender.java
@@ -17,6 +17,9 @@
  */
 package org.apache.hadoop.hdfs.server.datanode;
 
+import static org.apache.hadoop.io.nativeio.NativeIO.POSIX.POSIX_FADV_DONTNEED;
+import static org.apache.hadoop.io.nativeio.NativeIO.POSIX.POSIX_FADV_SEQUENTIAL;
+
 import java.io.BufferedInputStream;
 import java.io.DataInputStream;
 import java.io.DataOutputStream;
@@ -29,6 +32,11 @@
 import java.net.SocketTimeoutException;
 import java.nio.ByteBuffer;
 import java.nio.channels.FileChannel;
+import java.nio.file.FileStore;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.nio.file.Paths;
+import java.nio.file.StandardOpenOption;
 import java.util.Arrays;
 
 import org.apache.commons.logging.Log;
@@ -49,11 +57,14 @@
 import org.apache.hadoop.net.SocketOutputStream;
 import org.apache.hadoop.util.AutoCloseableLock;
 import org.apache.hadoop.util.DataChecksum;
+import org.apache.hadoop.util.DirectBufferPool;
 import org.apache.htrace.core.TraceScope;
 
 import static org.apache.hadoop.io.nativeio.NativeIO.POSIX.POSIX_FADV_DONTNEED;
 import static org.apache.hadoop.io.nativeio.NativeIO.POSIX.POSIX_FADV_SEQUENTIAL;
 
+import com.sun.nio.file.ExtendedOpenOption;
+
 import com.google.common.annotations.VisibleForTesting;
 import com.google.common.base.Preconditions;
 import org.slf4j.Logger;
@@ -175,7 +186,10 @@
    * See {{@link BlockSender#isLongRead()}
    */
   private static final long LONG_READ_THRESHOLD_BYTES = 256 * 1024;
-  
+ 
+  private DirectBufferPool pool = null;
+  private FileChannel directIOFileCh;
+  private int alignment = -1; 
 
   /**
    * Constructor
@@ -419,6 +433,18 @@
       blockIn = datanode.data.getBlockInputStream(block, offset); // seek to offset
       ris = new ReplicaInputStreams(
           blockIn, checksumIn, volumeRef, fileIoProvider);
+
+      Path path =
+          Paths.get(datanode.data.getBlockLocalPathInfo(block).getBlockPath());
+      // Need to pass directIO option here
+      directIOFileCh = FileChannel.open(path, StandardOpenOption.READ, ExtendedOpenOption.DIRECT);
+      FileStore fs = Files.getFileStore(path);
+      if (this.alignment == -1) {
+        // this.alignment = 1024; // Remove this and uncomment below line
+        this.alignment = fs.getBlockSize();
+        LOG.info("DirectIO ---->> {} ", alignment);
+      }
+      pool = new DirectBufferPool();
     } catch (IOException ioe) {
       IOUtils.closeStream(this);
       org.apache.commons.io.IOUtils.closeQuietly(blockIn);
@@ -582,15 +608,54 @@ private int sendPacket(ByteBuffer pkt, int maxChunks, OutputStream out,
         // First write header and checksums
         sockOut.write(buf, headerOff, dataOff - headerOff);
 
-        // no need to flush since we know out is not a buffered stream
-        FileChannel fileCh = ((FileInputStream)ris.getDataIn()).getChannel();
-        LongWritable waitTime = new LongWritable();
-        LongWritable transferTime = new LongWritable();
-        fileIoProvider.transferToSocketFully(
-            ris.getVolumeRef().getVolume(), sockOut, fileCh, blockInPosition,
-            dataLen, waitTime, transferTime);
-        datanode.metrics.addSendDataPacketBlockedOnNetworkNanos(waitTime.get());
-        datanode.metrics.addSendDataPacketTransferNanos(transferTime.get());
+         // ***********DIRECT-IO****
+        if (directIOFileCh != null) {
+          int oldLen = dataLen;
+          long oldStreamStart = blockInPosition; // lower limit, included
+          long oldStreamEnd = blockInPosition + oldLen; // Upper limit, not
+                                                        // included
+          long newStreamStart = alignment * (oldStreamStart / alignment);
+          long newStreamEnd = alignment * (oldStreamEnd / alignment + (oldStreamEnd % alignment == 0 ? 0 : 1));
+          int newLen = (int) (newStreamEnd - newStreamStart);
+
+          ByteBuffer newBuffer = pool.getBuffer(newLen + alignment - 1);//
+          System.out.println("ByteBuffer newBuffer.alignedSlice *** ");
+          // LOG.info("DirectIO ----newLen + alignment - 1>> {} ", newLen + alignment - 1);
+          newBuffer = newBuffer.alignedSlice(alignment);
+
+          int readBytes = directIOFileCh.read(newBuffer, newStreamStart);
+          // LOG.info("DirectIO ----readBytes>> {} ", readBytes);
+
+          int buffStartOffset = (int) (oldStreamStart - newStreamStart);
+          int buffEndOffset = buffStartOffset + oldLen;
+          int newReadBytes = readBytes - buffStartOffset;
+          newReadBytes = newReadBytes > oldLen ? oldLen : newReadBytes;
+
+          LOG.info("DirectIO ----StartOff : " + buffStartOffset);
+          LOG.info("DirectIO ----EndOff : " + buffEndOffset);
+          newBuffer.position(buffStartOffset);
+          newBuffer.limit(buffEndOffset);
+
+          // oldBuffer.put(newBuffer);
+
+          // return newReadBytes;
+          if (newBuffer.remaining() > 0) {
+            // sockOut.write(newBuffer);
+            IOUtils.writeFully(sockOut, newBuffer);
+          }
+          pool.returnBuffer(newBuffer);
+
+        } else {
+
+          // no need to flush since we know out is not a buffered stream
+          FileChannel fileCh = ((FileInputStream) ris.getDataIn()).getChannel();
+          LongWritable waitTime = new LongWritable();
+          LongWritable transferTime = new LongWritable();
+          fileIoProvider.transferToSocketFully(ris.getVolumeRef().getVolume(), sockOut, fileCh, blockInPosition,
+              dataLen, waitTime, transferTime);
+          datanode.metrics.addSendDataPacketBlockedOnNetworkNanos(waitTime.get());
+          datanode.metrics.addSendDataPacketTransferNanos(transferTime.get());
+        }
         blockInPosition += dataLen;
       } else {
         // normal transfer
